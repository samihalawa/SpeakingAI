<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8">
  <title>LanguagAI - Plataforma de Aprendizaje de Español</title>
  <!-- Tailwind CSS CDN -->
  <script src="https://cdn.tailwindcss.com"></script>
  <!-- DaisyUI Plugin -->
  <script>
    tailwind.config = {
      plugins: [daisyui],
      theme: {
        extend: {
          colors: {
            terracotta: '#E2725B',
            sunshine: '#FFD700',
            mediterranean: '#1E90FF',
            // Additional colors for dark mode
            'dark-bg': '#1F2937',
            'dark-text': '#F3F4F6',
          },
        },
      },
    };
  </script>
  <!-- DaisyUI CDN -->
  <link href="https://cdn.jsdelivr.net/npm/daisyui@2.51.5/dist/full.css" rel="stylesheet" type="text/css" />
  <!-- Axios CDN -->
  <script src="https://cdn.jsdelivr.net/npm/axios/dist/axios.min.js"></script>
  <!-- Tesseract.js for OCR -->
  <script src="https://cdn.jsdelivr.net/npm/tesseract.js@2.1.5/dist/tesseract.min.js"></script>
</head>
<body :class="{'bg-dark-bg text-dark-text': darkMode, 'bg-white text-gray-800': !darkMode}">
  <div id="app" class="min-h-screen flex flex-col">
    <!-- Header -->
    <header class="bg-terracotta p-4 text-white flex justify-between items-center">
      <h1 class="text-2xl font-bold">LanguagAI Español</h1>
      <button @click="toggleDarkMode" class="btn btn-circle btn-outline">
        <svg v-if="!darkMode" xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none"
             viewBox="0 0 24 24" stroke="currentColor">
          <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                d="M12 3v1m0 16v1m8.66-9h-1M4.34 12h-1m15.364 6.364l-.707-.707M6.343 6.343l-.707-.707m12.728 0l-.707.707M6.343 17.657l-.707.707M12 5a7 7 0 100 14 7 7 0 000-14z" />
        </svg>
        <svg v-else xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="currentColor"
             viewBox="0 0 20 20">
          <path d="M17.293 13.293A8 8 0 016.707 2.707a8.001 8.001 0 1010.586 10.586z" />
        </svg>
      </button>
    </header>

    <!-- Toast Notifications -->
    <div class="fixed top-4 right-4 z-50">
      <transition-group name="fade" tag="div">
        <div v-for="toast in toasts" :key="toast.id" class="alert alert-info shadow-lg mb-2">
          <div>
            <span>{{ toast.message }}</span>
          </div>
          <button @click="removeToast(toast.id)" class="btn btn-sm btn-circle btn-ghost" aria-label="Cerrar notificación">
            ✕
          </button>
        </div>
      </transition-group>
    </div>

    <!-- Main Content -->
    <main class="flex flex-1">
      <chat-view 
        :messages="messages"
        :user-input="userInput"
      >
        <template #input>
          <div class="flex">
            <input v-model="userInput" @keyup.enter="sendMessage" 
                   class="flex-1 p-2 border rounded-l focus:outline-none focus:ring-2 focus:ring-blue-500"
                   placeholder="Escribe tu mensaje..." aria-label="Input de chat">
            <button @click="sendMessage" 
                    class="bg-blue-500 text-white p-2 rounded-r hover:bg-blue-600 focus:outline-none focus:ring-2 focus:ring-blue-500" 
                    aria-label="Enviar mensaje">
              Enviar
            </button>
          </div>
        </template>
        <template #upload-buttons>
          <div class="mt-2 flex space-x-2">
            <input type="file" @change="handleImageUpload" accept="image/*" 
                   class="hidden" ref="imageInput">
            <button @click="$refs.imageInput.click()" class="btn btn-success" 
                    aria-label="Subir Imagen">
              <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 mr-1" fill="none"
                   viewBox="0 0 24 24" stroke="currentColor">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                      d="M3 5a2 2 0 012-2h3.586a2 2 0 011.414.586L12 7l1.586-1.414A2 2 0 0116.414 5H20a2 2 0 012 2v12a2 2 0 01-2 2H4a2 2 0 01-2-2V5z" />
              </svg>
              Imagen
            </button>
            <input type="file" @change="handleAudioUpload" accept="audio/*" 
                   class="hidden" ref="audioInput">
            <button @click="$refs.audioInput.click()" class="btn btn-warning" 
                    aria-label="Subir Audio">
              <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 mr-1" fill="none"
                   viewBox="0 0 24 24" stroke="currentColor">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                      d="M12 15v4m0-4a3 3 0 100-6 3 3 0 000 6zm0 0v-3m0 3h.01M19.07 4.93a10 10 0 11-14.14 0 10 10 0 0114.14 0z" />
              </svg>
              Audio
            </button>
          </div>
        </template>
      </chat-view>

      <vocabulary-view
        :vocabulary="vocabulary"
        :search-query.sync="searchQuery"
        :filter-type.sync="filterType"
        @copy="copyToClipboard"
        @edit="editVocabulary"
        @delete="deleteVocabulary"
        @add-tag="addTag"
      ></vocabulary-view>
    </main>

    <!-- Mobile Vocabulary Toggle -->
    <button @click="toggleVocabulary" class="md:hidden fixed bottom-4 right-4 bg-blue-500 text-white p-4 rounded-full shadow-lg" aria-label="Abrir vocabulario">
      <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none"
           viewBox="0 0 24 24" stroke="currentColor">
        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
              d="M4 6h16M4 12h16M4 18h16" />
      </svg>
    </button>
    <div v-if="showVocabulary" class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center">
      <div class="bg-white dark:bg-gray-800 w-11/12 h-3/4 p-4 rounded overflow-y-auto">
        <button @click="toggleVocabulary" class="btn btn-circle btn-outline btn-error float-right" aria-label="Cerrar vocabulario">✕</button>
        <h2 class="text-xl font-bold mb-4">Lista de Vocabulario</h2>
        <!-- Search and Filters -->
        <div class="mb-4">
          <input v-model="searchQuery" class="input input-bordered w-full mb-2" placeholder="Buscar vocabulario..." aria-label="Buscar vocabulario">
          <select v-model="filterType" class="select select-bordered w-full" aria-label="Filtrar por tipo">
            <option value="">Todos los tipos</option>
            <option value="word">Palabras</option>
            <option value="idiom">Modismos</option>
            <option value="expression">Expresiones</option>
          </select>
        </div>
        <!-- Vocabulary List -->
        <div>
          <transition-group name="fade" tag="div">
            <div v-for="word in filteredVocabulary" :key="word.id" class="mb-4 p-2 bg-gray-100 dark:bg-gray-700 rounded shadow">
              <div class="flex justify-between items-center">
                <h3 class="font-bold text-lg">{{ word.spanish }}</h3>
                <div class="flex space-x-2">
                  <button @click="copyToClipboard(word)" class="btn btn-xs btn-ghost" aria-label="Copiar">
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" fill="none"
                         viewBox="0 0 24 24" stroke="currentColor">
                      <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                            d="M8 16H6a2 2 0 01-2-2V6a2 2 0 012-2h8a2 2 0 012 2v2" />
                      <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                            d="M16 8l6 6-6 6" />
                    </svg>
                  </button>
                  <button @click="editVocabulary(word)" class="btn btn-xs btn-ghost" aria-label="Editar">
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" fill="none"
                         viewBox="0 0 24 24" stroke="currentColor">
                      <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                            d="M15.232 5.232l3.536 3.536M9.354 15.536L4.464 20.426a2 2 0 01-2.828-2.828L7.05 12.05a2 2 0 012.828 0l4.95 4.95a2 2 0 01-.001 2.828z" />
                    </svg>
                  </button>
                  <button @click="deleteVocabulary(word.id)" class="btn btn-xs btn-ghost text-red-500" aria-label="Eliminar">
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" fill="none"
                         viewBox="0 0 24 24" stroke="currentColor">
                      <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                            d="M6 18L18 6M6 6l12 12" />
                    </svg>
                  </button>
                </div>
              </div>
              <p class="text-gray-600 dark:text-gray-300">{{ word.chinese }}</p>
              <p class="text-sm text-gray-500 dark:text-gray-400">Añadido: {{ word.timestamp }}</p>
              <p class="text-sm text-gray-500 dark:text-gray-400">Tipo: {{ capitalize(word.type) }}</p>
              <ul class="list-disc ml-4 mt-2">
                <li v-for="(example, index) in word.examples" :key="index">{{ example }}</li>
              </ul>
              <!-- Custom Tags -->
              <div class="mt-2">
                <span v-for="tag in word.tags" :key="tag" class="badge badge-primary mr-1">{{ tag }}</span>
                <button @click="addTag(word)" class="btn btn-xs btn-outline ml-2" aria-label="Añadir etiqueta">+</button>
              </div>
            </div>
          </transition-group>
        </div>
      </aside>
    </main>

    <!-- Edit Vocabulary Modal -->
    <div v-if="editingVocabulary" class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center">
      <div class="bg-white dark:bg-gray-800 w-11/12 md:w-1/2 p-6 rounded shadow-lg">
        <h3 class="text-lg font-bold mb-4">Editar Vocabulario</h3>
        <form @submit.prevent="updateVocabulary">
          <div class="mb-4">
            <label class="block text-sm font-medium mb-1" for="spanish">Palabra en Español</label>
            <input type="text" id="spanish" v-model="editingVocabulary.spanish" class="input input-bordered w-full" required>
          </div>
          <div class="mb-4">
            <label class="block text-sm font-medium mb-1" for="chinese">Traducción al Chino</label>
            <input type="text" id="chinese" v-model="editingVocabulary.chinese" class="input input-bordered w-full" required>
          </div>
          <div class="mb-4">
            <label class="block text-sm font-medium mb-1" for="examples">Ejemplos de Uso (separados por comas)</label>
            <input type="text" id="examples" v-model="editingVocabulary.examplesText" class="input input-bordered w-full" required>
          </div>
          <div class="mb-4">
            <label class="block text-sm font-medium mb-1" for="type">Tipo</label>
            <select id="type" v-model="editingVocabulary.type" class="select select-bordered w-full" required>
              <option value="word">Palabra</option>
              <option value="idiom">Modismo</option>
              <option value="expression">Expresión</option>
            </select>
          </div>
          <div class="mb-4">
            <label class="block text-sm font-medium mb-1" for="tags">Etiquetas Personalizadas (separadas por comas)</label>
            <input type="text" id="tags" v-model="editingVocabulary.tagsText" class="input input-bordered w-full">
          </div>
          <div class="flex justify-end space-x-2">
            <button type="button" @click="cancelEdit" class="btn btn-ghost">Cancelar</button>
            <button type="submit" class="btn btn-primary">Guardar</button>
          </div>
        </form>
      </div>
    </div>

    <!-- Add Tag Modal -->
    <div v-if="addingTagVocabulary" class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center">
      <div class="bg-white dark:bg-gray-800 w-11/12 md:w-1/3 p-6 rounded shadow-lg">
        <h3 class="text-lg font-bold mb-4">Añadir Etiqueta</h3>
        <form @submit.prevent="addTagToVocabulary">
          <div class="mb-4">
            <label class="block text-sm font-medium mb-1" for="newTag">Nueva Etiqueta</label>
            <input type="text" id="newTag" v-model="newTag" class="input input-bordered w-full" required>
          </div>
          <div class="flex justify-end space-x-2">
            <button type="button" @click="cancelAddTag" class="btn btn-ghost">Cancelar</button>
            <button type="submit" class="btn btn-primary">Añadir</button>
          </div>
        </form>
      </div>
    </div>

    <!-- Footer -->
    <footer class="bg-terracotta p-4 text-white text-center">
      <p>&copy; 2024 LanguagAI Español</p>
    </footer>
  </div>

  <!-- Vue.js CDN -->
  <script src="https://cdn.jsdelivr.net/npm/vue@2"></script>
  <!-- Main Script -->
  <script>
    const CONFIG = {
      DATABASE_URL: "postgresql://neondb_owner:derbGji8KWI2@ep-holy-glitter-a59iygke.us-east-2.aws.neon.tech/kittyspanish?sslmode=require",
      OPENAI_API_KEY: "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"
    };

    const API = {
      async callOpenAI(prompt) {
        try {
          const response = await axios.post('https://api.openai.com/v1/chat/completions', {
            model: "gpt-4-turbo-preview",
            messages: [{ role: "user", content: prompt }],
            temperature: 0.7,
            max_tokens: 2000,
            presence_penalty: 0.6,
            frequency_penalty: 0.5
          }, {
            headers: {
              'Authorization': `Bearer ${CONFIG.OPENAI_API_KEY}`,
              'Content-Type': 'application/json'
            }
          });
          return response.data.choices[0].message.content;
        } catch (error) {
          console.error('OpenAI API Error:', error);
          throw error;
        }
      },

      async translateWithAI(text, fromLang, toLang) {
        const prompt = `Translate the following ${fromLang} text to ${toLang}. 
                       Also identify and explain any difficult vocabulary, idioms, or cultural references.
                       Return the response in JSON format with translation and vocabulary explanations.
                       Text: ${text}`;
        
        return this.callOpenAI(prompt);
      }
    };

    Vue.component('error-boundary', {
      data() {
        return {
          hasError: false,
          error: null
        }
      },
      methods: {
        handleError(error) {
          this.hasError = true;
          this.error = error;
          console.error('Error caught by boundary:', error);
        },
        retry() {
          this.hasError = false;
          this.error = null;
        }
      },
      template: `
        <div v-if="hasError" class="error-boundary p-4 bg-red-100 dark:bg-red-900 rounded-lg">
          <h3 class="text-lg font-bold text-red-700 dark:text-red-300">Something went wrong</h3>
          <p class="text-red-600 dark:text-red-400">{{ error && error.message }}</p>
          <button @click="retry" class="mt-2 btn btn-error">Retry</button>
        </div>
        <slot v-else></slot>
      `
    });

    Vue.component('chat-view', {
      props: ['messages', 'userInput'],
      template: `
        <section class="w-full md:w-2/3 p-4 flex flex-col">
          <div class="flex-1 overflow-y-auto mb-4" ref="chatContainer">
            <div v-for="message in messages" :key="message.id" class="mb-2">
              <div :class="{'text-right': message.sender === 'user', 'text-left': message.sender === 'ai'}">
                <div :class="message.sender === 'user' ? 'bg-orange-200 dark:bg-orange-700' : 'bg-blue-200 dark:bg-blue-700'"
                     class="inline-block p-2 rounded max-w-full break-words">
                  <p v-html="message.content"></p>
                </div>
              </div>
            </div>
          </div>
          <slot name="input"></slot>
          <slot name="upload-buttons"></slot>
        </section>
      `
    });

    Vue.component('vocabulary-view', {
      props: ['vocabulary', 'searchQuery', 'filterType'],
      template: `
        <aside class="hidden md:block w-1/3 p-4 bg-gray-100 dark:bg-gray-800 border-l overflow-y-auto">
          <h2 class="text-xl font-bold mb-4">Lista de Vocabulario</h2>
          <div class="mb-4">
            <input v-model="searchQuery" class="input input-bordered w-full mb-2" 
                   placeholder="Buscar vocabulario..." aria-label="Buscar vocabulario">
            <select v-model="filterType" class="select select-bordered w-full" 
                    aria-label="Filtrar por tipo">
              <option value="">Todos los tipos</option>
              <option value="word">Palabras</option>
              <option value="idiom">Modismos</option>
              <option value="expression">Expresiones</option>
            </select>
          </div>
          <div>
            <transition-group name="fade" tag="div">
              <div v-for="word in filteredVocabulary" :key="word.id" 
                   class="mb-4 p-2 bg-white dark:bg-gray-700 rounded shadow">
                <div class="flex justify-between items-center">
                  <h3 class="font-bold text-lg">{{ word.spanish }}</h3>
                  <div class="flex space-x-2">
                    <button @click="$emit('copy', word)" class="btn btn-xs btn-ghost" 
                            aria-label="Copiar">
                      <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" fill="none"
                           viewBox="0 0 24 24" stroke="currentColor">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                              d="M8 16H6a2 2 0 01-2-2V6a2 2 0 012-2h8a2 2 0 012 2v2" />
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                              d="M16 8l6 6-6 6" />
                      </svg>
                    </button>
                    <button @click="$emit('edit', word)" class="btn btn-xs btn-ghost" 
                            aria-label="Editar">
                      <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" fill="none"
                           viewBox="0 0 24 24" stroke="currentColor">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                              d="M15.232 5.232l3.536 3.536M9.354 15.536L4.464 20.426a2 2 0 01-2.828-2.828L7.05 12.05a2 2 0 012.828 0l4.95 4.95a2 2 0 01-.001 2.828z" />
                      </svg>
                    </button>
                    <button @click="$emit('delete', word.id)" 
                            class="btn btn-xs btn-ghost text-red-500" aria-label="Eliminar">
                      <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" fill="none"
                           viewBox="0 0 24 24" stroke="currentColor">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                              d="M6 18L18 6M6 6l12 12" />
                      </svg>
                    </button>
                  </div>
                </div>
                <p class="text-gray-600 dark:text-gray-300">{{ word.chinese }}</p>
                <p class="text-sm text-gray-500 dark:text-gray-400">
                  Añadido: {{ word.timestamp }}
                </p>
                <p class="text-sm text-gray-500 dark:text-gray-400">
                  Tipo: {{ capitalize(word.type) }}
                </p>
                <ul class="list-disc ml-4 mt-2">
                  <li v-for="(example, index) in word.examples" :key="index">
                    {{ example }}
                  </li>
                </ul>
                <div class="mt-2">
                  <span v-for="tag in word.tags" :key="tag" class="badge badge-primary mr-1">
                    {{ tag }}
                  </span>
                  <button @click="$emit('add-tag', word)" class="btn btn-xs btn-outline ml-2" 
                          aria-label="Añadir etiqueta">+</button>
                </div>
              </div>
            </transition-group>
          </div>
        </aside>
      `,
      computed: {
        filteredVocabulary() {
          return this.vocabulary.filter(word => {
            const matchesSearch = word.spanish.toLowerCase().includes(this.searchQuery.toLowerCase()) ||
                                word.chinese.toLowerCase().includes(this.searchQuery.toLowerCase()) ||
                                word.tags.some(tag => tag.toLowerCase().includes(this.searchQuery.toLowerCase()));
            const matchesType = this.filterType ? word.type === this.filterType : true;
            return matchesSearch && matchesType;
          });
        }
      },
      methods: {
        capitalize(str) {
          return str.charAt(0).toUpperCase() + str.slice(1);
        }
      }
    });

    new Vue({
      el: '#app',
      data: {
        userInput: '',
        messages: [],
        vocabulary: [],
        searchQuery: '',
        filterType: '',
        showVocabulary: false,
        darkMode: false,
        toasts: [],
        editingVocabulary: null,
        addingTagVocabulary: null,
        newTag: '',
        darkModeMediaQuery: null,
      },
      computed: {
        filteredVocabulary() {
          return this.vocabulary.filter(word => {
            const matchesSearch = word.spanish.toLowerCase().includes(this.searchQuery.toLowerCase()) ||
                                  word.chinese.toLowerCase().includes(this.searchQuery.toLowerCase()) ||
                                  word.tags.some(tag => tag.toLowerCase().includes(this.searchQuery.toLowerCase()));
            const matchesType = this.filterType ? word.type === this.filterType : true;
            return matchesSearch && matchesType;
          });
        }
      },
      methods: {
        capitalize(str) {
          return str.charAt(0).toUpperCase() + str.slice(1);
        },
        async sendMessage() {
          if (this.userInput.trim() === '') return;

          // Add user message
          this.messages.push({
            id: Date.now(),
            sender: 'user',
            content: this.formatMessage(this.userInput, 'user')
          });
          const userMessage = this.userInput;
          this.userInput = '';

          // Scroll to bottom
          this.$nextTick(() => {
            this.scrollToBottom();
          });

          // Generate prompt based on message language
          const prompt = this.generatePrompt(userMessage);

          // Show loading toast
          this.showToast('Procesando tu mensaje...', 'info');

          // Call AI API
          try {
            const aiResponse = await this.getAIResponse(prompt);

            // Remove loading toast
            this.toasts = this.toasts.filter(toast => toast.id !== aiResponse.loadingId);

            // Add AI message
            this.messages.push({
              id: Date.now(),
              sender: 'ai',
              content: this.formatMessage(aiResponse.responseText, 'ai')
            });

            // Update Vocabulary
            if (aiResponse.vocabulary && aiResponse.vocabulary.length > 0) {
              aiResponse.vocabulary.forEach(vocabItem => {
                // Assign unique ID
                vocabItem.id = Date.now() + Math.random();
                // Initialize tags
                vocabItem.tags = vocabItem.tags || [];
                // Add to vocabulary list
                this.vocabulary.push(vocabItem);
              });
            }

            // Scroll to bottom
            this.$nextTick(() => {
              this.scrollToBottom();
            });

            // Show success toast
            this.showToast('Mensaje procesado correctamente.', 'success');
          } catch (error) {
            console.error(error);
            // Remove loading toast
            this.toasts = this.toasts.filter(toast => toast.id !== aiResponse.loadingId);

            // Add error message
            this.messages.push({
              id: Date.now(),
              sender: 'ai',
              content: '<p>Error al obtener la respuesta del AI. Por favor, intenta nuevamente.</p>'
            });

            // Show error toast
            this.showToast('Error al procesar tu mensaje.', 'error');
          }
        },
        generatePrompt(message) {
          const chinesePattern = /[\u4e00-\u9fff]/;
          const isChinese = chinesePattern.test(message);
          
          if (isChinese) {
            return `As a Spanish language expert, translate this Chinese text to Spanish and analyze it:
            
            Text: "${message}"
            
            Please provide a response in the following JSON format:
            {
              "translation": "Spanish translation here",
              "vocabulary": [
                {
                  "spanish": "difficult word or phrase",
                  "chinese": "对应的中文",
                  "type": "word/idiom/expression",
                  "examples": ["Example sentence 1", "Example sentence 2"],
                  "explanation": "Detailed explanation in Chinese",
                  "level": "B1/B2/C1",
                  "tags": ["grammar", "colloquial", "formal", etc]
                }
              ],
              "grammar_notes": ["Any relevant grammar explanations in Chinese"],
              "cultural_notes": ["Any cultural context or usage notes in Chinese"]
            }`;
          } else {
            return `As a Chinese language expert, translate this Spanish text to Chinese and analyze it:
            
            Text: "${message}"
            
            Please provide a response in the following JSON format:
            {
              "translation": "Chinese translation here",
              "vocabulary": [
                {
                  "spanish": "palabra o frase difícil",
                  "chinese": "Chinese translation",
                  "type": "word/idiom/expression",
                  "examples": ["Example sentence 1", "Example sentence 2"],
                  "explanation": "Detailed explanation in Spanish",
                  "level": "B1/B2/C1",
                  "tags": ["grammar", "colloquial", "formal", etc]
                }
              ],
              "grammar_notes": ["Any relevant grammar explanations in Spanish"],
              "cultural_notes": ["Any cultural context or usage notes in Spanish"]
            }`;
          }
        },
        async getAIResponse(prompt) {
          const loadingId = Date.now() + Math.random();
          this.showToast('Procesando tu mensaje...', 'info', loadingId);

          try {
            const responseText = await API.callOpenAI(prompt);
            let parsedResponse;
            
            try {
              parsedResponse = JSON.parse(responseText);
            } catch (error) {
              console.error('Error parsing AI response:', error);
              throw new Error('Invalid AI response format');
            }

            // Process the response
            const processedResponse = {
              responseText: parsedResponse.translation,
              vocabulary: parsedResponse.vocabulary.map(item => ({
                id: Date.now() + Math.random(),
                spanish: item.spanish,
                chinese: item.chinese,
                type: item.type,
                examples: item.examples,
                timestamp: new Date().toLocaleString(),
                tags: [...(item.tags || []), item.level],
                explanation: item.explanation
              })),
              grammar_notes: parsedResponse.grammar_notes,
              cultural_notes: parsedResponse.cultural_notes,
              loadingId
            };

            // Format the response text with notes
            processedResponse.responseText = `
              <div class="translation-result">
                <p class="font-bold mb-2">${processedResponse.responseText}</p>
                ${processedResponse.grammar_notes.length > 0 ? `
                  <div class="grammar-notes mt-2 p-2 bg-gray-100 dark:bg-gray-700 rounded">
                    <h4 class="font-bold">Grammar Notes:</h4>
                    <ul class="list-disc ml-4">
                      ${processedResponse.grammar_notes.map(note => `<li>${note}</li>`).join('')}
                    </ul>
                  </div>
                ` : ''}
                ${processedResponse.cultural_notes.length > 0 ? `
                  <div class="cultural-notes mt-2 p-2 bg-gray-100 dark:bg-gray-700 rounded">
                    <h4 class="font-bold">Cultural Notes:</h4>
                    <ul class="list-disc ml-4">
                      ${processedResponse.cultural_notes.map(note => `<li>${note}</li>`).join('')}
                    </ul>
                  </div>
                ` : ''}
              </div>
            `;

            return processedResponse;
          } catch (error) {
            console.error('AI Response Error:', error);
            throw error;
          }
        },
        extractVocabularyFromResponse(responseData) {
          // Already handled in getAIResponse
          return responseData.vocabulary;
        },
        formatMessage(content, sender) {
          if (sender === 'ai') {
            return content; // The content is already formatted in getAIResponse
          }
          return `<p>${content}</p>`;
        },
        handleImageUpload(event) {
          const file = event.target.files[0];
          if (!file) return;

          // Validate file type
          if (!file.type.startsWith('image/')) {
            this.showToast('Por favor, sube un archivo de imagen válido.', 'error');
            return;
          }

          // Add loading toast
          this.showToast('Procesando imagen...', 'info');

          // Perform OCR using Tesseract.js
          Tesseract.recognize(
            file,
            'spa',
            { logger: m => console.log(m) }
          ).then(({ data: { text } }) => {
            // Remove loading toast
            this.removeLastToast();

            // Set extracted text as user input and send it
            this.userInput = text.trim();
            this.sendMessage();
          }).catch(error => {
            console.error(error);
            this.removeLastToast();
            this.showToast('Error al procesar la imagen. Por favor, intenta nuevamente.', 'error');
          });
        },
        async handleAudioUpload(event) {
          const file = event.target.files[0];
          if (!file) return;

          // Validate file type
          if (!file.type.startsWith('audio/')) {
            this.showToast('Por favor, sube un archivo de audio válido.', 'error');
            return;
          }

          // Add loading toast
          this.showToast('Transcribiendo audio...', 'info');

          try {
            // Convert audio file to base64
            const base64Audio = await this.convertToBase64(file);
            const base64Data = base64Audio.split(',')[1];

            // Call Hugging Face Whisper model for transcription
            const transcriptionResponse = await axios.post(
              'https://api-inference.huggingface.co/models/openai/whisper-base',
              {
                inputs: base64Data,
                options: { wait_for_model: true }
              },
              {
                headers: {
                  Authorization: `Bearer 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`,
                  'Content-Type': 'application/json'
                }
              }
            );

            if (transcriptionResponse.status !== 200) {
              throw new Error(`Transcription API error: ${transcriptionResponse.statusText}`);
            }

            const transcriptionText = transcriptionResponse.data.text;

            // Remove loading toast
            this.removeLastToast();

            if (!transcriptionText) {
              throw new Error('No se pudo transcribir el audio.');
            }

            // Set transcribed text as user input and send it
            this.userInput = transcriptionText.trim();
            this.sendMessage();

          } catch (error) {
            console.error(error);
            this.removeLastToast();
            this.showToast('Error al transcribir el audio. Por favor, intenta nuevamente.', 'error');
          }
        },
        convertToBase64(file) {
          return new Promise((resolve, reject) => {
            const reader = new FileReader();
            reader.readAsDataURL(file);
            reader.onload = () => resolve(reader.result);
            reader.onerror = error => reject(error);
          });
        },
        toggleVocabulary() {
          this.showVocabulary = !this.showVocabulary;
          if (this.showVocabulary) {
            document.body.style.overflow = 'hidden';
          } else {
            document.body.style.overflow = 'auto';
          }
        },
        scrollToBottom() {
          const container = this.$refs.chatContainer;
          if (container) {
            container.scrollTop = container.scrollHeight;
          }
        },
        showToast(message, type = 'info', id = null) {
          const toastId = id || Date.now() + Math.random();
          this.toasts = this.toasts.filter(t => t.type !== type);
          this.toasts.push({ id: toastId, message, type });
          setTimeout(() => {
            this.removeToast(toastId);
          }, 5000);
        },
        removeToast(id) {
          this.toasts = this.toasts.filter(toast => toast.id !== id);
        },
        removeLastToast() {
          this.toasts.pop();
        },
        copyToClipboard(word) {
          const textToCopy = `
Palabra: ${word.spanish}
Traducción: ${word.chinese}
Tipo: ${this.capitalize(word.type)}
Ejemplos:
${word.examples.map((ex, i) => `${i + 1}. ${ex}`).join('\n')}
${word.explanation ? `\nExplicación: ${word.explanation}` : ''}
${word.tags.length ? `\nEtiquetas: ${word.tags.join(', ')}` : ''}
          `.trim();

          try {
            await navigator.clipboard.writeText(textToCopy);
            this.showToast('Vocabulario copiado al portapapeles', 'success');
          } catch (err) {
            console.error('Error al copiar:', err);
            this.showToast('Error al copiar al portapapeles', 'error');
          }
        },
        editVocabulary(word) {
          this.editingVocabulary = {
            ...word,
            examplesText: word.examples.join(', '),
            tagsText: word.tags.join(', ')
          };
        },
        updateVocabulary() {
          if (!this.editingVocabulary) return;

          const index = this.vocabulary.findIndex(vocab => vocab.id === this.editingVocabulary.id);
          if (index !== -1) {
            const updatedVocab = {
              ...this.vocabulary[index],
              spanish: this.editingVocabulary.spanish,
              chinese: this.editingVocabulary.chinese,
              examples: this.editingVocabulary.examplesText.split(',').map(ex => ex.trim()),
              type: this.editingVocabulary.type,
              tags: this.editingVocabulary.tagsText ? this.editingVocabulary.tagsText.split(',').map(tag => tag.trim()) : []
            };
            
            this.$set(this.vocabulary, index, updatedVocab);
            this.saveVocabulary();
            this.showToast('Vocabulario actualizado correctamente', 'success');
            this.editingVocabulary = null;
          }
        },
        cancelEdit() {
          this.editingVocabulary = null;
        },
        deleteVocabulary(id) {
          if (confirm('¿Estás seguro de que deseas eliminar este vocabulario?')) {
            this.vocabulary = this.vocabulary.filter(vocab => vocab.id !== id);
            // Save to localStorage
            this.saveVocabulary();
            // Show success toast
            this.showToast('Vocabulario eliminado correctamente.', 'success');
          }
        },
        addTag(word) {
          this.addingTagVocabulary = word;
          this.newTag = '';
        },
        addTagToVocabulary() {
          if (!this.addingTagVocabulary || !this.newTag.trim()) return;

          const index = this.vocabulary.findIndex(vocab => vocab.id === this.addingTagVocabulary.id);
          if (index !== -1) {
            if (!this.vocabulary[index].tags.includes(this.newTag.trim())) {
              this.vocabulary[index].tags.push(this.newTag.trim());
              // Save to localStorage
              this.saveVocabulary();
              // Show success toast
              this.showToast('Etiqueta añadida correctamente.', 'success');
            } else {
              this.showToast('Esta etiqueta ya existe.', 'error');
            }
          }

          // Clear addingTagVocabulary
          this.addingTagVocabulary = null;
          this.newTag = '';
        },
        cancelAddTag() {
          this.addingTagVocabulary = null;
          this.newTag = '';
        },
        toggleDarkMode() {
          this.darkMode = !this.darkMode;
          localStorage.setItem('darkMode', this.darkMode);
          document.documentElement.classList.toggle('dark', this.darkMode);
        },
        loadDarkMode() {
          const savedMode = localStorage.getItem('darkMode');
          if (savedMode !== null) {
            this.darkMode = JSON.parse(savedMode);
          }
        },
        saveVocabulary() {
          localStorage.setItem('vocabulary', JSON.stringify(this.vocabulary));
        },
        loadVocabulary() {
          const savedVocab = localStorage.getItem('vocabulary');
          if (savedVocab) {
            this.vocabulary = JSON.parse(savedVocab);
          }
        },
        handleSystemDarkModeChange(e) {
          if (localStorage.getItem('darkMode') === null) {
            this.darkMode = e.matches;
          }
        },
        saveToLocalStorage() {
          try {
            localStorage.setItem('messages', JSON.stringify(this.messages));
            localStorage.setItem('vocabulary', JSON.stringify(this.vocabulary));
          } catch (error) {
            console.error('Error saving to localStorage:', error);
            this.showToast('Error saving data locally', 'error');
          }
        },
        loadFromLocalStorage() {
          try {
            const savedMessages = localStorage.getItem('messages');
            const savedVocabulary = localStorage.getItem('vocabulary');
            
            if (savedMessages) {
              this.messages = JSON.parse(savedMessages);
            }
            
            if (savedVocabulary) {
              this.vocabulary = JSON.parse(savedVocabulary);
            }
          } catch (error) {
            console.error('Error loading from localStorage:', error);
            this.showToast('Error loading saved data', 'error');
          }
        },
        autoSave() {
          this.saveToLocalStorage();
          this.showToast('Datos guardados automáticamente', 'info');
        }
      },
      created() {
        this.loadVocabulary();
        this.loadDarkMode();
        
        // Add system dark mode detection
        this.darkModeMediaQuery = window.matchMedia('(prefers-color-scheme: dark)');
        this.darkModeMediaQuery.addEventListener('change', this.handleSystemDarkModeChange);
        
        // Set initial dark mode if not set
        if (localStorage.getItem('darkMode') === null) {
          this.darkMode = this.darkModeMediaQuery.matches;
        }

        // Set up auto-save
        setInterval(this.autoSave, 300000); // Auto-save every 5 minutes

        // Load saved data
        this.loadFromLocalStorage();

        // Initialize dark mode
        document.documentElement.classList.toggle('dark', this.darkMode);
      }
    });
  </script>
  <!-- Custom Styles -->
  <style>
    .fade-enter-active, .fade-leave-active {
      transition: all 0.5s;
    }
    .fade-enter, .fade-leave-to {
      opacity: 0;
      transform: translateY(20px);
    }
    /* Responsive Adjustments */
    @media (max-width: 767px) {
      aside {
        display: none;
      }
    }
    .toast-container {
      position: fixed;
      top: 1rem;
      right: 1rem;
      z-index: 50;
      display: flex;
      flex-direction: column;
      gap: 0.5rem;
    }

    .toast {
      padding: 1rem;
      border-radius: 0.5rem;
      background-color: white;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
      display: flex;
      align-items: center;
      justify-content: space-between;
      min-width: 300px;
    }

    .toast-info {
      border-left: 4px solid #3b82f6;
    }

    .toast-success {
      border-left: 4px solid #10b981;
    }

    .toast-error {
      border-left: 4px solid #ef4444;
    }

    .dark .toast {
      background-color: #374151;
      color: white;
    }

    .fade-enter-active, 
    .fade-leave-active {
      transition: all 0.3s ease;
    }

    .fade-enter-from, 
    .fade-leave-to {
      opacity: 0;
      transform: translateX(30px);
    }

    /* Add to existing styles */
    .translation-result {
      @apply space-y-4;
    }

    .grammar-notes,
    .cultural-notes {
      @apply bg-gray-100 dark:bg-gray-700 p-4 rounded-lg;
    }

    .grammar-notes h4,
    .cultural-notes h4 {
      @apply text-lg font-bold mb-2;
    }

    .grammar-notes ul,
    .cultural-notes ul {
      @apply list-disc list-inside;
    }

    .vocabulary-item {
      @apply border-l-4 border-blue-500 pl-4 my-2;
    }

    .vocabulary-explanation {
      @apply text-sm text-gray-600 dark:text-gray-400;
    }

    .mobile-vocabulary {
      @apply fixed inset-0 bg-white dark:bg-gray-800 z-50 overflow-y-auto;
      transform: translateX(100%);
      transition: transform 0.3s ease-in-out;
    }

    .mobile-vocabulary.active {
      transform: translateX(0);
    }

    .chat-container {
      @apply flex-1 overflow-y-auto mb-4 p-4;
      scroll-behavior: smooth;
    }

    .message-bubble {
      @apply max-w-[80%] rounded-lg p-3 mb-2;
    }

    .user-message {
      @apply bg-orange-200 dark:bg-orange-700 ml-auto;
    }

    .ai-message {
      @apply bg-blue-200 dark:bg-blue-700;
    }

    .vocabulary-card {
      @apply bg-white dark:bg-gray-700 rounded-lg shadow-md p-4 mb-4 transition-all duration-200;
    }

    .vocabulary-card:hover {
      @apply shadow-lg transform -translate-y-1;
    }

    .button-icon {
      @apply w-5 h-5 inline-block align-middle;
    }

    .modal-overlay {
      @apply fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50;
    }

    .modal-content {
      @apply bg-white dark:bg-gray-800 rounded-lg shadow-xl p-6 w-11/12 max-w-2xl;
    }

    .input-field {
      @apply w-full border dark:border-gray-600 rounded-lg p-2 mb-4 focus:ring-2 focus:ring-blue-500;
    }
  </style>
</body>
</html>
